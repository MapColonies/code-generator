import {
  PropertiesTypes,
  ORMColumnType,
  IOrmCatalog,
  PycswLayerCatalogRecord,
  Pycsw3DCatalogRecord,
  PolygonPartRecord,
  ICatalogDBEntityMapping,
  IValidationConfigInfo,
  IPropCatalogDBMapping,
} from '@map-colonies/mc-model-types';
import { camelCase } from 'change-case-all';
import { ClassDeclaration, DecoratorStructure, OptionalKind, Project, Scope, SourceFile } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/ban-types, @typescript-eslint/no-inferrable-types */';

const generateORMRaster = async (output: string): Promise<void> => {
  const generator = new OrmGenerator(output, new PycswLayerCatalogRecord());
  await generator.generate();
};
Generator.register(Projects.RASTER, Tasks.ORM, generateORMRaster);

const generateORM3D = async (output: string): Promise<void> => {
  const generator = new OrmGenerator(output, new Pycsw3DCatalogRecord());
  await generator.generate();
};
Generator.register(Projects.THREED, Tasks.ORM, generateORM3D);

const generateORMPolygonPart = async (output: string): Promise<void> => {
  const generator = new OrmGenerator(output, new PolygonPartRecord());
  await generator.generate();
};
Generator.register(Projects.POLYGON_PARTS, Tasks.ORM, generateORMPolygonPart);

export class OrmGenerator {
  private readonly importManager: ImportManager;
  private project!: Project;
  private targetFile!: SourceFile;
  private relevantDecorators:  OptionalKind<DecoratorStructure>[] = [];

  public constructor(private readonly targetFilePath: string, private readonly entity: IOrmCatalog) {
    this.importManager = new ImportManager();
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();

    const ormEntity = this.entity.getORMCatalogEntityMappings();

    this.importManager.addImport('typeorm', ['Column', 'Entity']);
    const classDeclaration = this.createClass(ormEntity);
    this.addProperties(classDeclaration);

    this.importManager.generateImports(this.targetFile);

    await this.targetFile.save();
  }

  private addProperties(classDeclaration: ClassDeclaration): void {
    const dbFields = this.entity.getORMCatalogMappings();
    dbFields.forEach((field) => {
      const type = field.field?.overrideType !== undefined ? field.field.overrideType : field.mappingType;
      this.importManager.addType(type);
      let typeName = type.value;
      if (type.type == PropertiesTypes.ARRAY || type.type == PropertiesTypes.ENUM_ARRAY) {
        typeName = `${typeName}[]`;
      }
      let hasExclamationToken = field.column.nullable !== undefined;
      let initializer = this.valueToString((this.entity as unknown as Record<string, unknown>)[field.prop]);
      if (initializer !== undefined) {
        if (type.type == PropertiesTypes.ENUM) {
          initializer = `${initializer} as ${type.value}`;
        }
        hasExclamationToken = false;
      }

      const columnDecoratorName = field.column.columnType ?? ORMColumnType.COLUMN;
      this.importManager.addImport('typeorm', [columnDecoratorName]);
      field.index && this.importManager.addImport('typeorm', ['Index']);
      field.validation && this.importManager.addImport('typeorm', ['Check']);

      classDeclaration.addProperty({
        scope: Scope.Public,
        name: field.prop,
        type: typeName,
        initializer: initializer,
        hasExclamationToken: hasExclamationToken,
        hasQuestionToken: field.column.nullable,
        decorators: this.getRelevantDecorators(field),
      });
    });
  }

  private createClass(ormEntity: ICatalogDBEntityMapping): ClassDeclaration {
    const classDeclaration = this.targetFile.addClass({
      name: ormEntity.className,
      isExported: true,
    });
    classDeclaration.addDecorator({
      name: 'Entity',
      arguments: [`{name: '${ormEntity.table}'}`],
    });
    return classDeclaration;
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  }

  private objectToString(column: Record<string, unknown>): string {
    const dataParts: string[] = ['{'];
    const props = Object.entries(column);
    props.forEach((pair: [string, unknown], index: number) => {
      const parsed = this.valueToString(pair[1]);
      const value = parsed !== undefined ? parsed : 'undefined';
      let stringifyKey = `${pair[0]}: ${value}`;
      if (index !== props.length - 1) {
        stringifyKey += ',';
      }
      dataParts.push(stringifyKey);
    });
    dataParts.push('}');
    const data = dataParts.join('');
    data.trim();
    return data;
  }

  private valueToString(value: unknown): string | undefined {
    switch (typeof value) {
      case 'object':
        return this.objectToString(value as Record<string, unknown>);
      case 'bigint':
      case 'boolean':
      case 'number':
        return value.toString();
      case 'string':
        return `'${value}'`;
      case 'undefined':
        return undefined;
      case 'symbol':
      case 'function':
        throw new Error(`unsupported value type: ${typeof value}`);
    }
  }

  private getRelevantDecorators = (field: IPropCatalogDBMapping) => {
    const columnDecoratorName = field.column.columnType ?? ORMColumnType.COLUMN;
    const { columnType, ...rest } = field.column as unknown as Record<string, unknown>;
    const columnDecorator = { name: columnDecoratorName, arguments: [this.objectToString(rest)] };
    this.relevantDecorators.push(columnDecorator);

    if (field.index) {
      this.relevantDecorators.push({ name: 'Index', arguments: [this.objectToString({ ...field.index })] })
    }

    const generateCheck = process.argv.slice(2)
    console.log("generateCheck", generateCheck)

    // if(generateCheck){
      if (field.customChecks) {
        field.customChecks.map((check: { 'name'?: string, 'expression': string }) =>
          this.relevantDecorators.push({ name: 'Check', arguments: [`'${check.name}', "${check.expression}"`] }));
      }

      const minAndMaxValidations = field.validation?.filter((validation: IValidationConfigInfo) =>
        ((validation.min && (validation.min !== '$NOW')) || (validation.max && (validation.max !== '$NOW'))));
      
      field.validation?.map((validation: IValidationConfigInfo) =>{
        if(field.column.name && !minAndMaxValidations?.includes(validation) && (validation.max || validation.min || validation.pattern || validation.maxLength || validation.minLength))
        this.relevantDecorators.push({ name: 'Check', arguments: this.generateValidationArguments(validation, field.column.name) })
      });

      this.generateMinMaxCheckDecorator(minAndMaxValidations, field);
    // }

    return this.relevantDecorators;
  }

  private generateMinMaxCheckDecorator = (minAndMaxValidations: IValidationConfigInfo[] | undefined, field: IPropCatalogDBMapping) => {
    const mergedValidations: IValidationConfigInfo[] = [];
    let minValidation: IValidationConfigInfo | undefined;
    let maxValidation: IValidationConfigInfo | undefined;

    for (const validation of minAndMaxValidations || []) {
      if (validation.min) {
        minValidation = { ...validation }
      }
      if (validation.max) {
        maxValidation = { ...validation };
      }
    }

    if (minValidation && maxValidation) {
      mergedValidations.push({
        errorMsgCode: minValidation.errorMsgCode,
        valueType: minValidation.valueType,
        min: minValidation.min,
        max: maxValidation.max,
      });
    } else if (minValidation) {
      mergedValidations.push(minValidation);
    } else if (maxValidation) {
      mergedValidations.push(maxValidation);
    }

    mergedValidations?.map((validation) => {
      field.column.name && this.relevantDecorators.push({
        name: 'Check', arguments: 
          [`'${camelCase(field.column.name)}'`, `'${field.column.name} ${this.generateMinMaxExpression(validation, field.column.name)}'`]
      })
    });
  }

  private generateMinMaxExpression = (validation: IValidationConfigInfo, columnName: string) => {
    if ((validation.max && validation.min)) {
      return `BETWEEN ${validation.min ?? columnName} AND ${validation.max}`
    } else if (validation.max) {
      return `< ${validation.max}`
    } else {
      return `> ${validation.min}`
    }
  }

  private generateValidationArguments = (validation: IValidationConfigInfo, fieldCalumnName: string) => {
    if (validation.pattern) {
      return [`'${camelCase(fieldCalumnName)}'`, `'${fieldCalumnName} ${validation.pattern}'`]
    } else if (validation.min === '$NOW') {
      return [`'${camelCase(fieldCalumnName)}'`, `'${fieldCalumnName} > now()'`]
    } else if (validation.max === '$NOW') {
      return [`'${camelCase(fieldCalumnName)}'`, `'${fieldCalumnName} < now()'`]
    }
  }
}
