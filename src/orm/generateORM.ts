import { PropertiesTypes, IOrmCatalog, PycswLayerCatalogRecord, ICatalogDBEntityMapping } from '@map-colonies/mc-model-types';
import { ClassDeclaration, Project, Scope, SourceFile } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/ban-types, @typescript-eslint/no-inferrable-types */';

const generateORMRaster = async (output: string): Promise<void> => {
  const generator = new OrmGenerator(output, new PycswLayerCatalogRecord());
  await generator.generate();
};
Generator.register(Projects.RASTER, Tasks.ORM, generateORMRaster);

export class OrmGenerator {
  private readonly importManager: ImportManager;
  private project!: Project;
  private targetFile!: SourceFile;

  public constructor(private readonly targetFilePath: string, private readonly entity: IOrmCatalog) {
    this.importManager = new ImportManager();
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();

    const ormEntity = this.entity.getORMCatalogEntityMappings();

    this.importManager.addImport('typeorm', ['Column', 'Entity']);
    const classDeclaration = this.createClass(ormEntity);
    this.addProperties(classDeclaration);

    this.importManager.generateImports(this.targetFile);

    await this.targetFile.save();
  }

  private addProperties(classDeclaration: ClassDeclaration): void {
    const dbFields = this.entity.getORMCatalogMappings();
    dbFields.forEach((field) => {
      const type = field.field?.overrideType !== undefined ? field.field.overrideType : field.mappingType;
      this.importManager.addType(type);
      let typeName = type.value;
      if (type.type == PropertiesTypes.ARRAY || type.type == PropertiesTypes.ENUM_ARRAY) {
        typeName = `${typeName}[]`;
      }
      let hasExclamationToken = field.column.nullable !== undefined;
      let initializer = this.valueToString((this.entity as unknown as Record<string, unknown>)[field.prop]);
      if (initializer !== undefined) {
        if (type.type == PropertiesTypes.ENUM) {
          initializer = `${initializer} as ${type.value}`;
        }
        hasExclamationToken = false;
      }
      classDeclaration.addProperty({
        scope: Scope.Public,
        name: field.prop,
        type: typeName,
        initializer: initializer,
        hasExclamationToken: hasExclamationToken,
        hasQuestionToken: field.column.nullable,
        decorators: [
          {
            name: 'Column',
            arguments: [this.objectToString(field.column as unknown as Record<string, unknown>)],
          },
        ],
      });
    });
  }

  private createClass(ormEntity: ICatalogDBEntityMapping): ClassDeclaration {
    const classDeclaration = this.targetFile.addClass({
      name: ormEntity.className,
      isExported: true,
    });
    classDeclaration.addDecorator({
      name: 'Entity',
      arguments: [`{name: '${ormEntity.table}'}`],
    });
    return classDeclaration;
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  }

  private objectToString(column: Record<string, unknown>): string {
    const dataParts: string[] = ['{'];
    const props = Object.entries(column);
    props.forEach((pair: [string, unknown], index: number) => {
      const parsed = this.valueToString(pair[1]);
      const value = parsed !== undefined ? parsed : 'undefined';
      let stringifyKey = `${pair[0]}: ${value}`;
      if (index !== props.length - 1) {
        stringifyKey += ',';
      }
      dataParts.push(stringifyKey);
    });
    dataParts.push('}');
    const data = dataParts.join('');
    data.trim();
    return data;
  }

  private valueToString(value: unknown): string | undefined {
    switch (typeof value) {
      case 'object':
        return this.objectToString(value as Record<string, unknown>);
      case 'bigint':
      case 'boolean':
      case 'number':
        return value.toString();
      case 'string':
        return `'${value}'`;
      case 'undefined':
        return undefined;
      case 'symbol':
      case 'function':
        throw new Error(`unsupported value type: ${typeof value}`);
    }
  }
}
