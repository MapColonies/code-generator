import {
  PropertiesTypes,
  ORMColumnType,
  IOrmCatalog,
  PycswLayerCatalogRecord,
  Pycsw3DCatalogRecord,
  PolygonPartRecord,
  ICatalogDBEntityMapping,
  IValidationConfigInfo,
  IPropCatalogDBMapping,
} from '@map-colonies/mc-model-types';
import { camelCase } from 'change-case-all';
import { ClassDeclaration, DecoratorStructure, OptionalKind, Project, Scope, SourceFile, VariableDeclarationKind } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/ban-types, @typescript-eslint/no-inferrable-types */';

const generateORMRaster = async (output: string, ORMDecorators: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new PycswLayerCatalogRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.RASTER, Tasks.ORM, generateORMRaster);

const generateORM3D = async (output: string, ORMDecorators: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new Pycsw3DCatalogRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.THREED, Tasks.ORM, generateORM3D);

const generateORMPolygonPart = async (output: string, ORMDecorators: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new PolygonPartRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.POLYGON_PARTS, Tasks.ORM, generateORMPolygonPart);

export class OrmGenerator {
  private readonly importManager: ImportManager;
  private project!: Project;
  private targetFile!: SourceFile;
  private relevantDecorators: OptionalKind<DecoratorStructure>[] = [];
  private classDecorators: OptionalKind<DecoratorStructure>[] = [];

  public constructor(private readonly targetFilePath: string, private readonly entity: IOrmCatalog, private readonly ORMDecorators?: string[]) {
    this.importManager = new ImportManager();
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();

    const ormEntity = this.entity.getORMCatalogEntityMappings();

    this.importManager.addImport('typeorm', ['Column', 'Entity']);
    const classDeclaration = this.createClass(ormEntity);
    this.addProperties(classDeclaration);
    this.classDecorators.map((decrator)=> classDeclaration.addDecorator(decrator));
    this.importManager.generateImports(this.targetFile);

    await this.targetFile.save();
  }

  private addProperties(classDeclaration: ClassDeclaration): void {
    const dbFields = this.entity.getORMCatalogMappings();
    dbFields.forEach((field) => {
      const type = field.field?.overrideType !== undefined ? field.field.overrideType : field.mappingType;
      this.importManager.addType(type);
      let typeName = type.value;
      if (type.type == PropertiesTypes.ARRAY || type.type == PropertiesTypes.ENUM_ARRAY) {
        typeName = `${typeName}[]`;
      }
      let hasExclamationToken = field.column.nullable !== undefined;
      let initializer = this.valueToString(['', (this.entity as unknown as Record<string, unknown>)[field.prop]]);
      if (initializer !== undefined) {
        if (type.type == PropertiesTypes.ENUM) {
          initializer = `${initializer} as ${type.value}`;
        }
        hasExclamationToken = false;
      }

      const columnDecoratorName = field.column.columnType ?? ORMColumnType.COLUMN;
      this.importManager.addImport('typeorm', [columnDecoratorName]);
      field.index && this.importManager.addImport('typeorm', ['Index']);
      field.validation && this.importManager.addImport('typeorm', ['Check']);

      classDeclaration.addProperty({
        scope: Scope.Public,
        name: field.prop,
        type: typeName,
        isReadonly: field.field?.isReadonly,
        initializer: initializer,
        hasExclamationToken: hasExclamationToken,
        hasQuestionToken: field.column.nullable,
        decorators: this.getRelevantDecorators(field),
      });

      this.relevantDecorators = [];
      this.addEmptyLine(classDeclaration);
    });
  }

  private addEmptyLine = (classDeclaration: ClassDeclaration) => {
    const lastField = classDeclaration.getProperties().pop();
    const lastFieldPosition = lastField?.getPos();
    if (lastFieldPosition != undefined && lastFieldPosition >= 0) {
      classDeclaration.insertText(lastFieldPosition, '\n');
    }
  };

  private createClass(ormEntity: ICatalogDBEntityMapping): ClassDeclaration {
    const classDeclaration = this.targetFile.addClass({
      name: ormEntity.className,
      isExported: true,
    });
    classDeclaration.addDecorator({
      name: 'Entity',
      arguments: [`{name: '${ormEntity.table}'}`],
    });
    return classDeclaration;
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  }

  private objectToString(object: Record<string, unknown>): string {
    const dataParts: string[] = ['{ '];
    const props = Object.entries(object);
    if (props.length === 0){
      return '';
    }
    props.forEach((pair: [string, unknown], index: number) => {
      const parsed = this.valueToString(pair);
      const value = parsed !== undefined ? parsed : 'undefined';
      let stringifyKey = `${pair[0]}: ${value}`;
      if (index !== props.length - 1) {
        stringifyKey += ',';
      }
      dataParts.push(stringifyKey + ' ');
    });
    dataParts.push('}');
    const data = dataParts.join('');
    data.trim();

    return data;
  }

  private valueToString(pair: [string, unknown]): string | undefined {
    const value = pair[1];
    switch (typeof value) {
      case 'object':
        if (Array.isArray(value)) return `[${value.map((item) => `'${item}'`).join(', ')}]`;
        else {
          return this.objectToString(value as Record<string, unknown>);
        }
      case 'bigint':
      case 'boolean':
      case 'number':
        return value.toString();
      case 'string':
        return pair[0] !== 'enum' ? `'${value}'` : `${value}`;
      case 'undefined':
        return undefined;
      case 'symbol':
      case 'function':
        throw new Error(`unsupported value type: ${typeof value}`);
    }
  }

  private isDecoratorExists(decoratorName: string): boolean {
    const decoratorProp = decoratorName.toLocaleLowerCase();
    return !!this.ORMDecorators?.includes(decoratorProp);
  }

  private generateVariable = (generateValuesConstName: string, enumValues: string[]) => {
    this.targetFile?.insertVariableStatement(2, {
      isExported: true,
      declarationKind: VariableDeclarationKind.Const,
      declarations: [
        {
          name: `${generateValuesConstName}`,
          initializer: JSON.stringify(enumValues),
        },
      ],
    });
  };

  private getColumnWithEnum(field: IPropCatalogDBMapping): Record<string, unknown> {
    const { columnType, enum: { enumName, enumValues, enumType, generateValuesConstName } = {}, ...rest } = field.column;
    let columnWithEnumField: Record<string, unknown> = {
      ...rest,
      ...(enumName ? { enumName } : {}),
    };
    if (enumValues) {
      generateValuesConstName && this.generateVariable(generateValuesConstName, enumValues);
      columnWithEnumField = {
        ...columnWithEnumField,
        enum: generateValuesConstName ?? enumValues,
      };
    } else if (enumType) {
      columnWithEnumField = {
        ...rest,
        enumName,
        enum: enumType,
      };
    }
    return columnWithEnumField;
  }

  private getRelevantDecorators = (field: IPropCatalogDBMapping) => {
    const columnDecoratorName = field.column.columnType ?? ORMColumnType.COLUMN;
    const { columnType, ...rest } = field.column as unknown as Record<string, unknown>;
    const columnArguments: string[] = [];
    columnArguments.push(this.objectToString(field.column.enum ? this.getColumnWithEnum(field) : rest));
    const columnDecorator = { name: columnDecoratorName, arguments: columnArguments };
    this.relevantDecorators.push(columnDecorator);

    if (this.isDecoratorExists('index') && field.index) {
      this.relevantDecorators.push({ name: 'Index', arguments: [this.objectToString({ ...field.index })] });
    }

    if (this.isDecoratorExists('check')) {
      if (field.customChecks) {
        field.customChecks.map((check: { name?: string; expression: string }) =>
          this.relevantDecorators.push({ name: 'Check', arguments: [`'${check.name}', "${check.expression}"`] })
        );
      }

      const minAndMaxValidations = field.validation?.filter(
        (validation: IValidationConfigInfo) => (validation.min && validation.min !== '$NOW') || (validation.max && validation.max !== '$NOW')
      );

      field.validation?.map((validation: IValidationConfigInfo) => {
        if (
          field.column.name &&
          !minAndMaxValidations?.includes(validation) &&
          (validation.max || validation.min || validation.pattern || validation.maxLength || validation.minLength)
        ){
          if(validation.valueType ==='field'){
            this.classDecorators.push({ name: 'Check', arguments: this.generateValidationArguments(validation, field.column.name) });
          }else{
            this.relevantDecorators.push({ name: 'Check', arguments: this.generateValidationArguments(validation, field.column.name) });
          }
        }
      });

      this.generateMinMaxCheckDecorator(minAndMaxValidations, field.column.name ?? "");
    }

    return this.relevantDecorators;
  };

  private generateMinMaxCheckDecorator = (minAndMaxValidations: IValidationConfigInfo[] | undefined, columnName: string) => {
    const mergedValidations: IValidationConfigInfo[] = [];
    let minValidation: IValidationConfigInfo | undefined;
    let maxValidation: IValidationConfigInfo | undefined;

    for (const validation of minAndMaxValidations || []) {
      if (validation.min) {
        minValidation = { ...validation };
      }
      if (validation.max) {
        maxValidation = { ...validation };
      }
    }

    if (minValidation && maxValidation) {
      mergedValidations.push({
        errorMsgCode: minValidation.errorMsgCode,
        valueType: minValidation.valueType,
        min: minValidation.min,
        max: maxValidation.max,
      });
    } else if (minValidation) {
      mergedValidations.push(minValidation);
    } else if (maxValidation) {
      mergedValidations.push(maxValidation);
    }

    mergedValidations?.map((validation) => {
      const checkDecorator = {
        name: 'Check',
        arguments: [`'${camelCase(columnName)}'`, `'${columnName} ${this.generateMinMaxExpression(validation, columnName)}'`],
      };
      if(validation.valueType !== 'field'){
        this.relevantDecorators.push(checkDecorator)
      }else {
        this.classDecorators.push(checkDecorator)
      }
    });
  };

  private generateMinMaxExpression = (validation: IValidationConfigInfo, columnName: string) => {
    if (validation.max && validation.min) {
      return `BETWEEN ${validation.min ?? columnName} AND ${validation.max}`;
    } else if (validation.max) {
      return `< ${validation.max}`;
    } else {
      return `> ${validation.min}`;
    }
  };

  private generateValidationArguments = (validation: IValidationConfigInfo, fieldCalumnName: string) => {
    if (validation.pattern) {
      return [`'${camelCase(fieldCalumnName)}'`, `'${fieldCalumnName} ${validation.pattern}'`];
    } else if (validation.min === '$NOW') {
      return [`'${camelCase(fieldCalumnName)}'`, `'${fieldCalumnName} > now()'`];
    } else if (validation.max === '$NOW') {
      return [`'${camelCase(fieldCalumnName)}'`, `'${fieldCalumnName} < now()'`];
    }
  };
}
