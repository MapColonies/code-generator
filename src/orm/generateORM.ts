import { IColumnProps, IOrmCatalog, PycswLayerCatalogRecord, ICatalogDBEntityMapping } from '@map-colonies/mc-model-types';
import { ClassDeclaration, Project, Scope, SourceFile } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/ban-types */';

const generateORMRaster = async (output: string): Promise<void> => {
  const generator = new OrmGenerator(output, new PycswLayerCatalogRecord());
  await generator.generate();
};
Generator.register(Projects.RASTER, Tasks.ORM, generateORMRaster);

export class OrmGenerator {
  private readonly importManager: ImportManager;
  private project!: Project;
  private targetFile!: SourceFile;

  public constructor(private readonly targetFilePath: string, private readonly entity: IOrmCatalog) {
    this.importManager = new ImportManager();
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();

    const ormEntity = this.entity.getORMCatalogEntityMappings();

    this.importManager.addImport('typeorm', ['Column', 'Entity']);
    const classDeclaration = this.createClass(ormEntity);
    this.addProperties(classDeclaration);

    this.importManager.generateImports(this.targetFile);

    await this.targetFile.save();
  }

  private addProperties(classDeclaration: ClassDeclaration): void {
    const dbFields = this.entity.getORMCatalogMappings();
    dbFields.forEach((field) => {
      const type = field.field?.overrideType !== undefined ? field.field.overrideType : field.mappingType;
      this.importManager.addType(type);
      classDeclaration.addProperty({
        scope: Scope.Public,
        name: field.prop,
        type: type.value,
        hasExclamationToken: field.column.nullable !== undefined ? true : false,
        hasQuestionToken: field.column.nullable,
        decorators: [
          {
            name: 'Column',
            arguments: [this.objectToString(field.column)],
          },
        ],
      });
    });
  }

  private createClass(ormEntity: ICatalogDBEntityMapping): ClassDeclaration {
    const classDeclaration = this.targetFile.addClass({
      name: ormEntity.className,
      isExported: true,
    });
    classDeclaration.addDecorator({
      name: 'Entity',
      arguments: [`{name: '${ormEntity.table}'}`],
    });
    return classDeclaration;
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  }

  private objectToString(column: IColumnProps): string {
    const dataParts: string[] = ['{'];
    const props = Object.entries(column);
    props.forEach((pair: string[], index: number) => {
      const value: string = typeof pair[1] === 'string' ? `'${pair[1]}'` : pair[1];
      let stringifyKey = `${pair[0]}: ${value}`;
      if (index !== props.length - 1) {
        stringifyKey += ',';
      }
      dataParts.push(stringifyKey);
    });
    dataParts.push('}');
    const data = dataParts.join('');
    data.trim();
    return data;
  }
}
