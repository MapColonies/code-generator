import {
  PropertiesTypes,
  ORMColumnType,
  IOrmCatalog,
  PycswLayerCatalogRecord,
  Pycsw3DCatalogRecord,
  PolygonPartRecord,
  ICatalogDBEntityMapping,
  IValidationConfigInfo,
  IPropCatalogDBMapping,
} from '@map-colonies/mc-model-types';
import { camelCase } from 'change-case-all';
import { ClassDeclaration, DecoratorStructure, OptionalKind, Project, Scope, SourceFile } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';
import { generateVariable, objectToString, valueToString } from './orm.helper';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/ban-types, @typescript-eslint/no-inferrable-types */';

const generateORMRaster = async (output: string, ORMDecorators?: string[], useNamingStrategy?: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new PycswLayerCatalogRecord(), ORMDecorators, useNamingStrategy);
  await generator.generate();
};
Generator.register(Projects.RASTER, Tasks.ORM, generateORMRaster);

const generateORM3D = async (output: string, ORMDecorators?: string[], useNamingStrategy?: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new Pycsw3DCatalogRecord(), ORMDecorators, useNamingStrategy);
  await generator.generate();
};
Generator.register(Projects.THREED, Tasks.ORM, generateORM3D);

const generateORMPolygonPart = async (output: string, ORMDecorators?: string[], useNamingStrategy?: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new PolygonPartRecord(), ORMDecorators, useNamingStrategy);
  await generator.generate();
};
Generator.register(Projects.POLYGON_PARTS, Tasks.ORM, generateORMPolygonPart);

export class OrmGenerator {
  private readonly importManager: ImportManager;
  private readonly classDecorators: OptionalKind<DecoratorStructure>[] = [];
  private project!: Project;
  private targetFile!: SourceFile;
  private relevantDecorators: OptionalKind<DecoratorStructure>[] = [];

  public constructor(private readonly targetFilePath: string, private readonly entity: IOrmCatalog, private readonly ORMDecorators?: string[], private readonly useNamingStrategy?: string[]) {
    this.importManager = new ImportManager();
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();

    const ormEntity = this.entity.getORMCatalogEntityMappings();

    this.importManager.addImport('typeorm', ['Column']);
    const classDeclaration = this.createClass(ormEntity);
    this.addProperties(classDeclaration);
    this.classDecorators.map((decrator) => classDeclaration.addDecorator(decrator));
    this.importManager.generateImports(this.targetFile);

    await this.targetFile.save();
  }

  private addProperties(classDeclaration: ClassDeclaration): void {
    const dbFields = this.entity.getORMCatalogMappings();

    const propertySeparator = (): void => {
      const lastField = classDeclaration.getProperties().pop();
      const lastFieldPosition = lastField?.getPos();
      if (lastFieldPosition != undefined && lastFieldPosition >= 0) {
        classDeclaration.insertText(lastFieldPosition, '\n');
      }
    };

    dbFields.forEach((fieldDescriptor) => {
      const type = fieldDescriptor.field?.overrideType !== undefined ? fieldDescriptor.field.overrideType : fieldDescriptor.mappingType;
      this.importManager.addType(type);
      let typeName = type.value;
      if (type.type == PropertiesTypes.ARRAY || type.type == PropertiesTypes.ENUM_ARRAY) {
        typeName = `${typeName}[]`;
      }
      let hasExclamationToken = fieldDescriptor.column.nullable !== undefined;
      let initializer = valueToString(['', (this.entity as unknown as Record<string, unknown>)[fieldDescriptor.prop]]);
      if (initializer !== undefined) {
        if (type.type == PropertiesTypes.ENUM) {
          initializer = `${initializer} as ${type.value}`;
        }
        hasExclamationToken = false;
      }

      const columnDecoratorName = fieldDescriptor.column.columnType ?? ORMColumnType.COLUMN;
      this.importManager.addImport('typeorm', [columnDecoratorName]);

      if (this.isDecoratorExists('index') && fieldDescriptor.index) {
        this.importManager.addImport('typeorm', ['Index']);
      }

      if (this.isDecoratorExists('check') && (fieldDescriptor.validation || fieldDescriptor.customChecks)) {
        this.importManager.addImport('typeorm', ['Check']);
      }

      classDeclaration.addProperty({
        scope: Scope.Public,
        name: fieldDescriptor.prop,
        type: typeName,
        isReadonly: fieldDescriptor.field?.isReadonly,
        initializer: initializer,
        hasExclamationToken: hasExclamationToken,
        hasQuestionToken: fieldDescriptor.column.nullable,
        decorators: this.getRelevantDecorators(fieldDescriptor),
      });

      this.relevantDecorators = [];
      propertySeparator();
    });
  }

  private createClass(ormEntity: ICatalogDBEntityMapping): ClassDeclaration {
    const classDeclaration = this.targetFile.addClass({
      name: ormEntity.className,
      isExported: true,
    });

    if (ormEntity.isPartial !== true) {
      this.importManager.addImport('typeorm', ['Entity']);
      classDeclaration.addDecorator({
        name: 'Entity',
        arguments: [`{ name: '${ormEntity.table}' }`],
      });
    }
    return classDeclaration;
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  }

  private isDecoratorExists(decoratorName: string): boolean {
    const decoratorProp = decoratorName.toLocaleLowerCase();
    return this.ORMDecorators?.includes(decoratorProp) ?? false;
  }

  private getRelevantDecorators(field: IPropCatalogDBMapping): OptionalKind<DecoratorStructure>[] {
    const columnDecoratorName = field.column.columnType ?? ORMColumnType.COLUMN;
    const { columnType, ...rest } = field.column as unknown as Record<string, unknown>;
    const columnArguments: string[] = [];

    let fieldArguments = '';
    if (field.column.columnType !== 'PrimaryGeneratedColumn') {
      fieldArguments = objectToString(field.column.enum ? this.getColumnWithEnum(field) : rest);
    } else {
      const { type, nullable, ...leftOver } = rest;
      const objSize = Object.keys(leftOver).length;
      if (typeof type === 'string') {
        fieldArguments = objSize > 0 ? `'${type}', ${objectToString(leftOver)}` : `'${type}'`;
      }
    }
    columnArguments.push(fieldArguments);
    const columnDecorator = { name: columnDecoratorName, arguments: columnArguments };
    this.relevantDecorators.push(columnDecorator);

    if (this.isDecoratorExists('index') && field.index) {
      this.relevantDecorators.push({ name: 'Index', arguments: [objectToString({ ...field.index })] });
    }

    if (this.isDecoratorExists('check')) {
      if (field.customChecks) {
        field.customChecks.map((check: { name?: string; expression: string }) =>
          this.relevantDecorators.push({
            name: 'Check',
            arguments: this.useNamingStrategy?.includes('check') === true? [`"${check.expression}"`]:
              [`'${check.name ?? ''}', "${check.expression}"`],
          })
        );
      }

      const minAndMaxValidations = field.validation?.filter(
        (validation: IValidationConfigInfo) =>
          (validation.min != undefined && validation.min !== '$NOW') || (validation.max != undefined && validation.max !== '$NOW')
      );

      field.validation?.map((validation: IValidationConfigInfo) => {
        if (
          field.column.name !== undefined &&
          minAndMaxValidations &&
          !minAndMaxValidations.includes(validation) &&
          (validation.max != undefined ||
            validation.min != undefined ||
            validation.pattern != undefined ||
            validation.maxLength != undefined ||
            validation.minLength != undefined)
        ) {
          if (validation.valueType === 'field') {
            this.classDecorators.push({ name: 'Check', arguments: this.getCheckDecoratorArguments(validation, field.column.name) });
          } else {
            this.relevantDecorators.push({ name: 'Check', arguments: this.getCheckDecoratorArguments(validation, field.column.name) });
          }
        }
      });

      this.updateMinMaxCheckDecorator(minAndMaxValidations, field.column.name ?? '');
    }

    return this.relevantDecorators;
  }

  private getColumnWithEnum(field: IPropCatalogDBMapping): Record<string, unknown> {
    const { columnType, enum: { enumName, enumValues, enumType, generateValuesConstName } = {}, ...rest } = field.column;
    let columnWithEnumField: Record<string, unknown> = {
      ...rest,
      ...(enumName != '' && enumName != undefined ? { enumName } : {}),
    };
    if (enumValues) {
      const position = 2;
      if (generateValuesConstName !== '' && generateValuesConstName != undefined) {
        generateVariable(this.targetFile, position, generateValuesConstName, enumValues, 'Const');
      }
      columnWithEnumField = {
        ...columnWithEnumField,
        enum: generateValuesConstName ?? enumValues,
      };
    } else if (enumType != undefined && enumType != '') {
      columnWithEnumField = {
        ...rest,
        enumName,
        enum: enumType,
      };
    }
    return columnWithEnumField;
  }

  private updateMinMaxCheckDecorator(minAndMaxValidations: IValidationConfigInfo[] | undefined, columnName: string): void {
    const mergedValidations: IValidationConfigInfo[] = [];
    let minValidation: IValidationConfigInfo | undefined;
    let maxValidation: IValidationConfigInfo | undefined;

    const getMinMaxExpression = (validation: IValidationConfigInfo, columnName: string): string => {
      if (validation.max != undefined && validation.min != undefined) {
        return `BETWEEN ${columnName} AND ${validation.max}`;
      } else if (validation.max != undefined) {
        return `< ${validation.max}`;
      } else if (validation.min != undefined) {
        return `> ${validation.min}`;
      }
      return '';
    };

    for (const validation of minAndMaxValidations ?? []) {
      if (validation.min != undefined) {
        minValidation = { ...validation };
      }
      if (validation.max != undefined) {
        maxValidation = { ...validation };
      }
    }

    if (minValidation && maxValidation) {
      mergedValidations.push({
        errorMsgCode: minValidation.errorMsgCode,
        valueType: minValidation.valueType,
        min: minValidation.min,
        max: maxValidation.max,
      });
    } else if (minValidation) {
      mergedValidations.push(minValidation);
    } else if (maxValidation) {
      mergedValidations.push(maxValidation);
    }

    mergedValidations.map((validation) => {
      const checkDecorator = {
        name: 'Check',
        arguments: this.useNamingStrategy?.includes('check') === true? [`'"${columnName}" ${getMinMaxExpression(validation, columnName)}'`]: [`'${camelCase(columnName)}'`, `'"${columnName}" ${getMinMaxExpression(validation, columnName)}'`],
      };
      if (validation.valueType !== 'field') {
        this.relevantDecorators.push(checkDecorator);
      } else {
        this.classDecorators.push(checkDecorator);
      }
    });
  }

  private getCheckDecoratorArguments(validation: IValidationConfigInfo, fieldCalumnName: string): string[] | undefined {
    if (validation.pattern != undefined) {
      const pattern = validation.pattern;
      return [
        `${this.useNamingStrategy?.includes('check') === true ? `'"${pattern.includes('\\') ? pattern.replace(/\\/g, '\\\\\\\\') : pattern}"'`:
          `'"${fieldCalumnName}" ~ "${pattern.includes('\\') ? pattern.replace(/\\/g, '\\\\\\\\') : pattern}"'`}`
      ];
    } else if (validation.min === '$NOW') {
      return this.useNamingStrategy?.includes('check') === true ? [`'"${fieldCalumnName}" > now()'`]:
        [`'${camelCase(fieldCalumnName)}'`, `'"${fieldCalumnName}" > now()'`];
    } else if (validation.max === '$NOW') {
      return this.useNamingStrategy?.includes('check') === true ? [`'"${fieldCalumnName}" < now()'`]:
        [`'${camelCase(fieldCalumnName)}'`, `'"${fieldCalumnName}" < now()'`];
    }
  }
}
