import {
  PropertiesTypes,
  ORMColumnType,
  IOrmCatalog,
  PycswLayerCatalogRecord,
  Pycsw3DCatalogRecord,
  PolygonPartRecord,
  ICatalogDBEntityMapping,
  IPropCatalogDBMapping,
} from '@map-colonies/mc-model-types';
import { ClassDeclaration, Project, Scope, SourceFile, VariableDeclarationKind } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/ban-types, @typescript-eslint/no-inferrable-types */';

type Decorator = {
  name: string;
  arguments: string[];
};

const SUPPORTED_DECORATORS = ['Index', 'Check'];

const generateORMRaster = async (output: string, ORMDecorators: Record<string, unknown>): Promise<void> => {
  const generator = new OrmGenerator(output, new PycswLayerCatalogRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.RASTER, Tasks.ORM, generateORMRaster);

const generateORM3D = async (output: string, ORMDecorators: Record<string, unknown>): Promise<void> => {
  const generator = new OrmGenerator(output, new Pycsw3DCatalogRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.THREED, Tasks.ORM, generateORM3D);

const generateORMPolygonPart = async (output: string, ORMDecorators: Record<string, unknown>): Promise<void> => {
  const generator = new OrmGenerator(output, new PolygonPartRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.POLYGON_PARTS, Tasks.ORM, generateORMPolygonPart);

export class OrmGenerator {
  private readonly importManager: ImportManager;
  private project!: Project;
  private targetFile!: SourceFile;

  public constructor(
    private readonly targetFilePath: string,
    private readonly entity: IOrmCatalog,
    private readonly optDec?: Record<string, unknown>
  ) {
    this.importManager = new ImportManager();
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();

    const ormEntity = this.entity.getORMCatalogEntityMappings();

    console.log('ormEntity', ormEntity);
    this.importManager.addImport('typeorm', ['Column', 'Entity']);
    const classDeclaration = this.createClass(ormEntity);
    this.addProperties(classDeclaration);

    this.importManager.generateImports(this.targetFile);

    await this.targetFile.save();
  }

  //add column decorator
  private addProperties(classDeclaration: ClassDeclaration): void {
    const dbFields = this.entity.getORMCatalogMappings();
    dbFields.forEach((field) => {
      const type = field.field?.overrideType != undefined ? field.field.overrideType : field.mappingType;

      this.importManager.addType(type);
      let typeName = type.value;
      if (type.type == PropertiesTypes.ARRAY || type.type == PropertiesTypes.ENUM_ARRAY) {
        typeName = `${typeName}[]`;
      }
      let hasExclamationToken = !field.column.nullable;
      let initializer = this.valueToString(['DUMMY', (this.entity as unknown as Record<string, unknown>)[field.prop]]);

      if (initializer !== undefined) {
        if (type.type == PropertiesTypes.ENUM) {
          initializer = `${initializer} as ${type.value}`;
        }
        hasExclamationToken = false;
      }

      const columnDecoratorName = field.column.columnType ?? ORMColumnType.COLUMN;
      const filteredDecorators = SUPPORTED_DECORATORS.filter((dec) => {
        return this.isDecoratorExists(dec, field);
      });

      this.importManager.addImport('typeorm', [columnDecoratorName, ...filteredDecorators]);

      const updateRest = this.updateWithEnumIfExist(field);

      const decorators: Decorator[] = [
        {
          name: columnDecoratorName,
          arguments: [this.objectToString(updateRest)],
        },
      ];

      SUPPORTED_DECORATORS.forEach((dec) => {
        const decObj = this.getDecoratorInfo(dec, field);
        if (decObj) {
          decorators.push(decObj);
        }
      });

      classDeclaration.addProperty({
        scope: Scope.Public,
        name: field.prop,
        type: typeName,
        isReadonly: field.field?.isReadonly,
        initializer: initializer,
        hasExclamationToken: hasExclamationToken,
        hasQuestionToken: field.column.nullable,
        decorators: decorators,
      });

      const lastProperty = classDeclaration.getProperties().pop();
      const lastPropertyPos = lastProperty?.getPos();

      if (lastPropertyPos != null) {
        classDeclaration.insertText(lastPropertyPos, '\n');
      }
    });
  }

  private updateWithEnumIfExist(field: IPropCatalogDBMapping): Record<string, unknown> {
    const { columnType, enum: { enumName, enumValues, enumType, generateValuesConstName } = {}, ...rest } = field.column;

    let updateRest: Record<string, unknown> = {
      ...rest,
      ...(enumName != null ? { enumName } : {}),
    };

    if (enumValues) {
      if (generateValuesConstName) {
        this.targetFile.insertVariableStatement(2, {
          isExported: true,
          declarationKind: VariableDeclarationKind.Const,
          declarations: [
            {
              name: `${generateValuesConstName}`,
              initializer: JSON.stringify(enumValues),
            },
          ],
        });

        updateRest = {
          ...updateRest,
          enum: generateValuesConstName,
        };
      } else {
        updateRest = {
          ...updateRest,
          enum: enumValues,
        };
      }
    } else if (enumType) {
      updateRest = {
        ...rest,
        enumName,
        enum: enumType,
      };
    }

    return updateRest;
  }

  private isDecoratorExists(decoratorName: string, field: IPropCatalogDBMapping): boolean {
    const decoratorProp = decoratorName.toLocaleLowerCase();
    // const dfdf: boolean | undefined = (this.optDec?.[decoratorProp] && fieldObj[decoratorProp]) ?? false
    return !!(this.optDec?.[decoratorProp] && (field as unknown as Record<string, unknown>)[decoratorProp]);
  }

  private getDecoratorInfo(decoratorName: string, field: IPropCatalogDBMapping): Decorator | undefined {
    let decoVal = undefined;
    const decoratorProp = decoratorName.toLocaleLowerCase();
    const fieldObj = field as unknown as Record<string, unknown>;

    if (this.isDecoratorExists(decoratorName, field)) {
      decoVal = {
        name: decoratorName,
        arguments: [this.objectToString({ ...(fieldObj[decoratorProp] as Record<string, unknown>) })],
      };
    }
    return decoVal;
  }

  private createClass(ormEntity: ICatalogDBEntityMapping): ClassDeclaration {
    const classDeclaration = this.targetFile.addClass({
      name: ormEntity.className,
      isExported: true,
    });

    classDeclaration.addDecorator({
      name: 'Entity',
      arguments: [`{name: '${ormEntity.table}'}`],
    });
    return classDeclaration;
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  }

  private objectToString(column: Record<string, unknown>): string {
    const dataParts: string[] = ['{ '];
    const props = Object.entries(column);
    props.forEach((pair: [string, unknown], index: number) => {
      const parsed = this.valueToString(pair);
      const value = parsed !== undefined ? parsed : 'undefined';
      let stringifyKey = `${pair[0]}: ${value}`;
      if (index !== props.length - 1) {
        stringifyKey += ',';
      }
      dataParts.push(stringifyKey + ' ');
    });
    dataParts.push('}');
    const data = dataParts.join('');
    data.trim();
    return data;
  }

  private valueToString(pair: [string, unknown]): string | undefined {
    const value = pair[1];
    switch (typeof value) {
      case 'object':
        return !pair[0].includes('enum') ? this.objectToString(value as Record<string, unknown>) : `[${this.mapToStrings(value)}]`;
      case 'bigint':
      case 'boolean':
      case 'number':
        return value.toString();
      case 'string':
        return pair[0] !== 'enum' ? `'${value}'` : `${value}`;
      case 'undefined':
        return undefined;
      case 'symbol':
      case 'function':
        throw new Error(`unsupported value type: ${typeof value}`);
    }
  }

  private mapToStrings = (value: string[] | unknown): string[] => {
    if (Array.isArray(value)) return value.map((item) => `'${item}'`);
    return [];
  };
}
