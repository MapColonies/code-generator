import {
  PropertiesTypes,
  ORMColumnType,
  IOrmCatalog,
  PycswLayerCatalogRecord,
  Pycsw3DCatalogRecord,
  PolygonPartRecord,
  ICatalogDBEntityMapping,
  IValidationConfigInfo,
  IPropCatalogDBMapping,
} from '@map-colonies/mc-model-types';
import { camelCase } from 'change-case-all';
import { ClassDeclaration, DecoratorStructure, OptionalKind, Project, Scope, SourceFile } from 'ts-morph';
import { generateVariable, objectToString, valueToString } from './orm.helper';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/ban-types, @typescript-eslint/no-inferrable-types */';

const generateORMRaster = async (output: string, ORMDecorators: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new PycswLayerCatalogRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.RASTER, Tasks.ORM, generateORMRaster);

const generateORM3D = async (output: string, ORMDecorators: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new Pycsw3DCatalogRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.THREED, Tasks.ORM, generateORM3D);

const generateORMPolygonPart = async (output: string, ORMDecorators: string[]): Promise<void> => {
  const generator = new OrmGenerator(output, new PolygonPartRecord(), ORMDecorators);
  await generator.generate();
};
Generator.register(Projects.POLYGON_PARTS, Tasks.ORM, generateORMPolygonPart);

export class OrmGenerator {
  private readonly importManager: ImportManager;
  private project!: Project;
  private targetFile!: SourceFile;
  private relevantDecorators: OptionalKind<DecoratorStructure>[] = [];
  private classDecorators: OptionalKind<DecoratorStructure>[] = [];

  public constructor(private readonly targetFilePath: string, private readonly entity: IOrmCatalog, private readonly ORMDecorators?: string[]) {
    this.importManager = new ImportManager();
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();

    const ormEntity = this.entity.getORMCatalogEntityMappings();

    this.importManager.addImport('typeorm', ['Column', 'Entity']);
    const classDeclaration = this.createClass(ormEntity);
    this.addProperties(classDeclaration);
    this.classDecorators.map((decrator) => classDeclaration.addDecorator(decrator));
    this.importManager.generateImports(this.targetFile);

    await this.targetFile.save();
  }

  private addProperties(classDeclaration: ClassDeclaration): void {
    const dbFields = this.entity.getORMCatalogMappings();

    const propertySeparator = () => {
      const lastField = classDeclaration.getProperties().pop();
      const lastFieldPosition = lastField?.getPos();
      if (lastFieldPosition != undefined && lastFieldPosition >= 0) {
        classDeclaration.insertText(lastFieldPosition, '\n');
      }
    };

    dbFields.forEach((fieldDescriptor) => {
      const type = fieldDescriptor.field?.overrideType !== undefined ? fieldDescriptor.field.overrideType : fieldDescriptor.mappingType;
      this.importManager.addType(type);
      let typeName = type.value;
      if (type.type == PropertiesTypes.ARRAY || type.type == PropertiesTypes.ENUM_ARRAY) {
        typeName = `${typeName}[]`;
      }
      let hasExclamationToken = fieldDescriptor.column.nullable !== undefined;
      let initializer = valueToString(['', (this.entity as unknown as Record<string, unknown>)[fieldDescriptor.prop]]);
      if (initializer !== undefined) {
        if (type.type == PropertiesTypes.ENUM) {
          initializer = `${initializer} as ${type.value}`;
        }
        hasExclamationToken = false;
      }

      const columnDecoratorName = fieldDescriptor.column.columnType ?? ORMColumnType.COLUMN;
      this.importManager.addImport('typeorm', [columnDecoratorName]);
      fieldDescriptor.index && this.importManager.addImport('typeorm', ['Index']);
      fieldDescriptor.validation && this.importManager.addImport('typeorm', ['Check']);

      classDeclaration.addProperty({
        scope: Scope.Public,
        name: fieldDescriptor.prop,
        type: typeName,
        isReadonly: fieldDescriptor.field?.isReadonly,
        initializer: initializer,
        hasExclamationToken: hasExclamationToken,
        hasQuestionToken: fieldDescriptor.column.nullable,
        decorators: this.getRelevantDecorators(fieldDescriptor),
      });

      this.relevantDecorators = [];
      propertySeparator();
    });
  }

  private createClass(ormEntity: ICatalogDBEntityMapping): ClassDeclaration {
    const classDeclaration = this.targetFile.addClass({
      name: ormEntity.className,
      isExported: true,
    });
    classDeclaration.addDecorator({
      name: 'Entity',
      arguments: [`{name: '${ormEntity.table}'}`],
    });
    return classDeclaration;
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  }

  private isDecoratorExists(decoratorName: string): boolean {
    const decoratorProp = decoratorName.toLocaleLowerCase();
    return !!this.ORMDecorators?.includes(decoratorProp);
  }

  private getRelevantDecorators = (field: IPropCatalogDBMapping) => {
    const columnDecoratorName = field.column.columnType ?? ORMColumnType.COLUMN;
    const { columnType, ...rest } = field.column as unknown as Record<string, unknown>;
    const columnArguments: string[] = [];
    columnArguments.push(objectToString(field.column.enum ? this.getColumnWithEnum(field) : rest));
    const columnDecorator = { name: columnDecoratorName, arguments: columnArguments };
    this.relevantDecorators.push(columnDecorator);

    if (this.isDecoratorExists('index') && field.index) {
      this.relevantDecorators.push({ name: 'Index', arguments: [objectToString({ ...field.index })] });
    }

    if (this.isDecoratorExists('check')) {
      if (field.customChecks) {
        field.customChecks.map((check: { name?: string; expression: string }) =>
          this.relevantDecorators.push({ name: 'Check', arguments: [`'${check.name}', "${check.expression}"`] })
        );
      }

      const minAndMaxValidations = field.validation?.filter(
        (validation: IValidationConfigInfo) => (validation.min && validation.min !== '$NOW') || (validation.max && validation.max !== '$NOW')
      );

      field.validation?.map((validation: IValidationConfigInfo) => {
        if (
          field.column.name &&
          !minAndMaxValidations?.includes(validation) &&
          (validation.max || validation.min || validation.pattern || validation.maxLength || validation.minLength)
        ) {
          if (validation.valueType === 'field') {
            this.classDecorators.push({ name: 'Check', arguments: this.getCheckDecoratorArguments(validation, field.column.name) });
          } else {
            this.relevantDecorators.push({ name: 'Check', arguments: this.getCheckDecoratorArguments(validation, field.column.name) });
          }
        }
      });

      this.updateMinMaxCheckDecorator(minAndMaxValidations, field.column.name ?? '');
    }

    return this.relevantDecorators;
  };

  private getColumnWithEnum(field: IPropCatalogDBMapping): Record<string, unknown> {
    const { columnType, enum: { enumName, enumValues, enumType, generateValuesConstName } = {}, ...rest } = field.column;
    let columnWithEnumField: Record<string, unknown> = {
      ...rest,
      ...(enumName ? { enumName } : {}),
    };
    if (enumValues) {
      generateValuesConstName && generateVariable(this.targetFile, 2, generateValuesConstName, enumValues, 'Const');
      columnWithEnumField = {
        ...columnWithEnumField,
        enum: generateValuesConstName ?? enumValues,
      };
    } else if (enumType) {
      columnWithEnumField = {
        ...rest,
        enumName,
        enum: enumType,
      };
    }
    return columnWithEnumField;
  }

  private updateMinMaxCheckDecorator = (minAndMaxValidations: IValidationConfigInfo[] | undefined, columnName: string) => {
    const mergedValidations: IValidationConfigInfo[] = [];
    let minValidation: IValidationConfigInfo | undefined;
    let maxValidation: IValidationConfigInfo | undefined;

    const getMinMaxExpression = (validation: IValidationConfigInfo, columnName: string) => {
      if (validation.max && validation.min) {
        return `BETWEEN ${validation.min ?? columnName} AND ${validation.max}`;
      } else if (validation.max) {
        return `< ${validation.max}`;
      } else {
        return `> ${validation.min}`;
      }
    };

    for (const validation of minAndMaxValidations || []) {
      if (validation.min) {
        minValidation = { ...validation };
      }
      if (validation.max) {
        maxValidation = { ...validation };
      }
    }

    if (minValidation && maxValidation) {
      mergedValidations.push({
        errorMsgCode: minValidation.errorMsgCode,
        valueType: minValidation.valueType,
        min: minValidation.min,
        max: maxValidation.max,
      });
    } else if (minValidation) {
      mergedValidations.push(minValidation);
    } else if (maxValidation) {
      mergedValidations.push(maxValidation);
    }

    mergedValidations?.map((validation) => {
      const checkDecorator = {
        name: 'Check',
        arguments: [`'${camelCase(columnName)}'`, `'"${columnName}" ${getMinMaxExpression(validation, columnName)}'`],
      };
      if (validation.valueType !== 'field') {
        this.relevantDecorators.push(checkDecorator);
      } else {
        this.classDecorators.push(checkDecorator);
      }
    });
  };

  private getCheckDecoratorArguments = (validation: IValidationConfigInfo, fieldCalumnName: string) => {
    if (validation.pattern) {
      const pattern = validation.pattern;
      return [
        `'${camelCase(fieldCalumnName)}'`,
        `'"${fieldCalumnName}" ~ "${pattern.includes('\\') ? pattern.replace(/\\/g, '\\\\\\\\') : pattern}"'`,
      ];
    } else if (validation.min === '$NOW') {
      return [`'${camelCase(fieldCalumnName)}'`, `'"${fieldCalumnName}" > now()'`];
    } else if (validation.max === '$NOW') {
      return [`'${camelCase(fieldCalumnName)}'`, `'"${fieldCalumnName}" < now()'`];
    }
  };
}
