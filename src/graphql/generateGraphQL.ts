import {
  IPropGraphQLMapping,
  getGraphQLClassMapping,
  IDescribeTsType,
  PropertiesTypes,
  TsTypes,
  IGraphQLClassMapping,
} from '@map-colonies/mc-model-types';
import { ClassDeclaration, Project, Scope, SourceFile, VariableDeclarationKind } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/naming-convention */';
const NOT_FOUND = -1;

const generateGraphQLRaster = async (output: string): Promise<void> => {
  const generator = new GraphqlGenerator(output);
  await generator.generate();
};

Generator.register(Projects.RASTER, Tasks.GRAPHQL, generateGraphQLRaster);

export class GraphqlGenerator {
  private readonly importManager: ImportManager;
  private project: Project = new Project();
  private targetFile: SourceFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });

  public constructor(private readonly targetFilePath: string) {
    this.importManager = new ImportManager();
  }

  private initGeneratedFile(): void {
    this.project = new Project();
    this.targetFile = this.project.createSourceFile(this.targetFilePath, {}, { overwrite: true });
    this.targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
    this.targetFile.addImportDeclaration({
      namedImports: ['InputType', 'ObjectType', 'Field', 'Resolver', 'registerEnumType'],
      moduleSpecifier: 'type-graphql',
    });
  }

  public async generate(): Promise<void> {
    this.initGeneratedFile();
    const graphQLClasses = getGraphQLClassMapping();
    this.addProperties(graphQLClasses);
    await this.targetFile.save();
  }

  private addProperties = async (graphQLClasses: IGraphQLClassMapping[]): Promise<void> => {
    const addFieldDecorator = (field: IPropGraphQLMapping, classDeclaration: ClassDeclaration) => {
      classDeclaration.addProperty({
        scope: Scope.Public,
        name: field.prop,
        type: this.getType(field.mappingType),
        hasQuestionToken: field.nullable,
        decorators: [
          {
            name: 'Field',
            arguments: this.parseOptions(field, this.targetFile),
          },
        ],
      });
    };

    this.targetFile.addImportDeclaration({
      namedImports: ['GraphQLScalarType'],
      moduleSpecifier: 'graphql',
    });

    //#region Generate input/output entity classes
    ['InputType', 'ObjectType'].forEach((graphQLClassType: string) => {
      graphQLClasses.forEach((graphQLClass) => {
        const classDeclaration = this.targetFile.addClass({
          name: graphQLClassType.indexOf('Input') > NOT_FOUND ? `${graphQLClass.name}Input` : graphQLClass.name,
          isExported: true,
        });
        classDeclaration.addDecorator({
          name: graphQLClassType,
          arguments: [],
        });

        graphQLClass.fields.forEach((field) => {
          if (graphQLClassType.indexOf('Input') > NOT_FOUND) {
            if (!field.isAutoGenerated && !field.isLifecycleEnvolved) {
              addFieldDecorator(field, classDeclaration);
            }
          } else {
            addFieldDecorator(field, classDeclaration);
          }
        });
      });
    });
    //#endregion

    //#region Generate resolver classes
    graphQLClasses.forEach((graphQLClass) => {
      const classDeclaration = this.targetFile.addClass({
        name: `${graphQLClass.name}Resolver`,
        isExported: true,
      });
      classDeclaration.addDecorator({
        name: 'Resolver',
        arguments: [graphQLClass.name],
      });
    });
    this.importEnums(this.targetFile);
    await this.targetFile.save();
  };

  private getType = (mappingType: IDescribeTsType, isParseOptions?: boolean): string => {
    if (mappingType.type === PropertiesTypes.ARRAY || mappingType.type === PropertiesTypes.ENUM_ARRAY) {
      if (Object.values(TsTypes).find((t) => t.value === mappingType.value && t.type === PropertiesTypes.CLASS)) {
        return isParseOptions ? `${mappingType.value}Input` : `${mappingType.value}Input[]`;
      }
      return isParseOptions ? `${mappingType.value}` : `${mappingType.value}[]`;
    }
    if (mappingType.type === PropertiesTypes.OBJECT) {
      return `Record<string, unknown>`;
    } else if (mappingType.type === PropertiesTypes.CLASS) {
      return `${mappingType.value}Input`;
    }
    return mappingType.value;
  };

  private createNewScalarType = (name: string, targetFile: SourceFile): void => {
    const scalarName = `${name}Object`;
    const exists = targetFile.getVariableDeclaration(scalarName);

    if (!exists) {
      targetFile.addVariableStatement({
        declarationKind: VariableDeclarationKind.Const,
        declarations: [
          {
            name: scalarName,
            initializer: `new GraphQLScalarType({ name: "${scalarName}"})`,
          },
        ],
        isExported: true,
      });
    }
  };

  /* eslint-disable @typescript-eslint/naming-convention, no-case-declarations */
  private parseOptions = (field: IPropGraphQLMapping, targetFile: SourceFile): string[] => {
    const parseValue = (value: string) => {
      return value === 'string' ? 'String' : value;
    };

    const args: string[] = [];
    let returnType = '';

    switch (field.mappingType.type) {
      case PropertiesTypes.ENUM:
        this.importManager.addType(field.mappingType);
        returnType = `(type) => ${parseValue(field.mappingType.value)}`;
        break;

      case PropertiesTypes.ENUM_ARRAY:
        this.importManager.addType(field.mappingType);
        returnType = `(type) => [${parseValue(field.mappingType.value)}]`;
        break;

      case PropertiesTypes.CLASS:
        returnType = `(type) => ${parseValue(this.getType(field.mappingType, true))}`;
        break;

      case PropertiesTypes.ARRAY:
        returnType = `(type) => [${parseValue(this.getType(field.mappingType, true))}]`;
        break;

      case PropertiesTypes.OBJECT:
        returnType = `(type) => ${field.prop}Object`;
        this.createNewScalarType(field.prop, targetFile);
        break;

      case PropertiesTypes.PRIMITIVE:
        returnType = `(type) => [${parseValue(field.mappingType.value)}]`;
        break;
    }

    if (returnType) {
      args.push(returnType);
    }
    args.push(`{ nullable: ${Boolean(field.nullable).toString()} }`);
    return args;
  };
  /* eslint-enable @typescript-eslint/naming-convention */

  private importEnums = (targetFile: SourceFile): void => {
    this.importManager.generateImports(targetFile);
    const allImports = this.importManager.getImports();
    for (const key of Object.keys(allImports)) {
      allImports[key]?.forEach((module) => {
        const registerEnums = `registerEnumType(${module}, {name: "${module}"})`;
        targetFile.addVariableStatement({
          declarationKind: VariableDeclarationKind.Const,
          declarations: [
            {
              name: `${module}Register`,
              initializer: registerEnums,
            },
          ],
        });
      });
    }
  };
}
