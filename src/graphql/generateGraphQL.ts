import { IPropGraphQLMapping, getGraphQLClassMapping, IDescribeTsType, PropertiesTypes, TsTypes } from '@map-colonies/mc-model-types';
import { ClassDeclaration, Project, Scope, SourceFile, VariableDeclarationKind } from 'ts-morph';
import Generator from '../generator';
import { Projects, Tasks } from '../models/enums';
import { ImportManager } from '../utills/importManager';

const AUTO_GENERATED_COMMENT = '/* This file was auto-generated by MC-GENERATOR, DO NOT modify it manually */';
const DISABLE_LINT_RULES = '/* eslint-disable import/exports-last, @typescript-eslint/naming-convention */';
const NOT_FOUND = -1;
let importManager: ImportManager;

const generateGraphQL = async (targetFilePath: string): Promise<void> => {
  importManager = new ImportManager();
  const graphQLClasses = getGraphQLClassMapping();
  const project = new Project();
  const targetFile = project.createSourceFile(targetFilePath, {}, { overwrite: true });

  const addFieldDecorator = (field: IPropGraphQLMapping, classDeclaration: ClassDeclaration, graphQLClassType: string): void => {
    classDeclaration.addProperty({
      scope: Scope.Public,
      name: field.prop,
      type: getType(field.mappingType, graphQLClassType),
      hasQuestionToken: field.nullable,
      decorators: [
        {
          name: 'Field',
          arguments: parseOptions(field, targetFile, graphQLClassType),
        },
      ],
    });
  };

  targetFile.insertStatements(0, AUTO_GENERATED_COMMENT + '\n' + DISABLE_LINT_RULES);
  targetFile.addImportDeclaration({
    namedImports: ['InputType', 'ObjectType', 'Field', 'Resolver', 'registerEnumType'],
    moduleSpecifier: 'type-graphql',
  });

  targetFile.addImportDeclaration({
    namedImports: ['GraphQLScalarType'],
    moduleSpecifier: 'graphql',
  });

  //#region Generate input/output entity classes
  ['InputType', 'ObjectType'].forEach((graphQLClassType: string) => {
    graphQLClasses.forEach((graphQLClass) => {
      const classDeclaration = targetFile.addClass({
        name: graphQLClassType.indexOf('Input') > NOT_FOUND ? `${graphQLClass.name}Input` : graphQLClass.name,
        isExported: true,
      });
      classDeclaration.addDecorator({
        name: graphQLClassType,
        arguments: [],
      });

      graphQLClass.fields.forEach((field) => {
        if (graphQLClassType.indexOf('Input') > NOT_FOUND) {
          if (field.isAutoGenerated !== true && field.isLifecycleEnvolved !== true) {
            addFieldDecorator(field, classDeclaration, graphQLClassType);
          }
        } else {
          addFieldDecorator(field, classDeclaration, graphQLClassType);
        }
      });
    });
  });
  //#endregion

  //#region Generate resolver classes
  graphQLClasses.forEach((graphQLClass) => {
    const classDeclaration = targetFile.addClass({
      name: `${graphQLClass.name}Resolver`,
      isExported: true,
    });
    classDeclaration.addDecorator({
      name: 'Resolver',
      arguments: [graphQLClass.name],
    });
  });
  //#endregion

  //#region TODO: Generate partial update class if needed, but go over dynamic classes rathere than explicit ones
  // interface IClasssPropFieldConfigInfo extends IPropFieldConfigInfo {
  //   className: string;
  // }
  // let editableRecordsFields: IClasssPropFieldConfigInfo[] = [];
  // [PycswLayerCatalogRecord, Pycsw3DCatalogRecord].forEach(recordType => {
  //   editableRecordsFields = editableRecordsFields.concat(
  //     recordType.getFieldConfigs().filter((field) => field.isManuallyEditable === true).map(classField => {
  //       return {
  //         // @ts-ignore
  //         className: (recordType.__proto__ as Record<string,string>).name,
  //         ...classField
  //       }
  //     })
  //   );
  // });
  // const editableFields = Array.from(new Set(editableRecordsFields.map(field => field.prop)))
  //   .map(prop => {
  //     const fieldConfig = editableRecordsFields.find(fld => fld.prop === prop);
  //     return {
  //       ...fieldConfig
  //     }
  //   }) as IClasssPropFieldConfigInfo[];
  // const classDeclaration = targetFile.addClass({
  //   name: 'RecordsEditableFields',
  //   isExported: true,
  // });
  // classDeclaration.addDecorator({
  //   name: 'InputType',
  //   arguments: [],
  // });

  // editableFields.forEach(editableField => {
  //     const graphQLClass = graphQLClasses.find(gClass => gClass.name === 'LayerRasterRecord'/*editableField.className*/);
  //     console.log('graphQLClass--->', graphQLClass, editableField.className);
  //     if(graphQLClass !== undefined){
  //       const field = graphQLClass.fields.find(field => field.prop === editableField.prop);
  //       if(field !== undefined){
  //         classDeclaration.addProperty({
  //           scope: Scope.Public,
  //           name: editableField.prop,
  //           type: getType(field.mappingType),
  //           hasQuestionToken: true,
  //           decorators: [
  //             {
  //               name: 'Field',
  //               arguments: parseOptions(field, targetFile),
  //             },
  //           ],
  //         });
  //         classDeclaration.addProperty({
  //           scope: Scope.Public,
  //           name: editableField.prop,
  //           type: getType(field.mappingType),
  //           hasQuestionToken: true,
  //           decorators: [
  //             {
  //               name: 'Field',
  //               arguments: parseOptions(field, targetFile),
  //             },
  //           ],
  //         });
  //       }
  //     }
  //   });
  //#endregion

  importEnums(targetFile);
  await targetFile.save();
};

const getType = (mappingType: IDescribeTsType, graphQLClassType?: string, isParseOptions = false): string => {
  if (mappingType.type === PropertiesTypes.ARRAY || mappingType.type === PropertiesTypes.ENUM_ARRAY) {
    if (
      Object.values(TsTypes).find((t) => t.value === mappingType.value && t.type === PropertiesTypes.CLASS) &&
      graphQLClassType &&
      graphQLClassType.indexOf('Input') > NOT_FOUND
    ) {
      return isParseOptions ? `${mappingType.value}Input` : `${mappingType.value}Input[]`;
    }
    return isParseOptions ? `${mappingType.value}` : `${mappingType.value}[]`;
  }
  if (mappingType.type === PropertiesTypes.OBJECT) {
    return `Record<string, unknown>`;
  } else if (mappingType.type === PropertiesTypes.CLASS) {
    return `${mappingType.value}Input`;
  }
  return mappingType.value;
};

const createNewScalarType = (name: string, targetFile: SourceFile): void => {
  const scalarName = `${name}Object`;
  const exists = targetFile.getVariableDeclaration(scalarName);

  if (!exists) {
    targetFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [
        {
          name: scalarName,
          initializer: `new GraphQLScalarType({ name: "${scalarName}"})`,
        },
      ],
      isExported: true,
    });
  }
};

/* eslint-disable @typescript-eslint/naming-convention, no-case-declarations */
const parseOptions = (field: IPropGraphQLMapping, targetFile: SourceFile, graphQLClassType: string): string[] => {
  const parseValue = (value: string): string => {
    return value === 'string' ? 'String' : value;
  };

  const args: string[] = [];
  let returnType = '';

  switch (field.mappingType.type) {
    case PropertiesTypes.ENUM:
      importManager.addType(field.mappingType);
      returnType = `(type) => ${parseValue(field.mappingType.value)}`;
      break;

    case PropertiesTypes.ENUM_ARRAY:
      importManager.addType(field.mappingType);
      returnType = `(type) => [${parseValue(field.mappingType.value)}]`;
      break;

    case PropertiesTypes.CLASS:
      returnType = `(type) => ${parseValue(getType(field.mappingType, graphQLClassType, true))}`;
      break;

    case PropertiesTypes.ARRAY:
      returnType = `(type) => [${parseValue(getType(field.mappingType, graphQLClassType, true))}]`;
      break;

    case PropertiesTypes.OBJECT:
      returnType = `(type) => ${field.prop}Object`;
      createNewScalarType(field.prop, targetFile);
      break;

    case PropertiesTypes.PRIMITIVE:
      break;
  }

  if (returnType) {
    args.push(returnType);
  }
  args.push(`{ nullable: ${Boolean(field.nullable).toString()} }`);
  return args;
};
/* eslint-enable @typescript-eslint/naming-convention */

const importEnums = (targetFile: SourceFile): void => {
  importManager.generateImports(targetFile);
  const allImports = importManager.getImports();
  for (const key of Object.keys(allImports)) {
    allImports[key]?.forEach((module) => {
      const registerEnums = `registerEnumType(${module}, {name: "${module}"})`;
      targetFile.addVariableStatement({
        declarationKind: VariableDeclarationKind.Const,
        declarations: [
          {
            name: `${module}Register`,
            initializer: registerEnums,
          },
        ],
      });
    });
  }
};

const generateGraphQLRaster = async (output: string): Promise<void> => {
  await generateGraphQL(output);
};

Generator.register(Projects.RASTER, Tasks.GRAPHQL, generateGraphQLRaster);
